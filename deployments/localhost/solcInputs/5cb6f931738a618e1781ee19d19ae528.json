{
  "language": "Solidity",
  "sources": {
    "contracts/FundMe.sol": {
      "content": "/*\npragma solidity ^0.8.8;\n\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\nimport \"./PriceConverter.sol\";\n\nerror NotOwner();\n\ncontract FundMe {\n    using PriceConverter for uint256;\n\n    mapping(address => uint256) public addressToAmountFunded;\n    address[] public funders;\n\n    // Could we make this constant?  /* hint: no! We should make it immutable! */\n    // address public /* immutable */ i_owner;\n    // uint256 public constant MINIMUM_USD = 50 * 10 ** 18;\n    \n    // constructor() {\n    //     i_owner = msg.sender;\n    // }\n\n    // function fund() public payable {\n    //     require(msg.value.getConversionRate() >= MINIMUM_USD, \"You need to spend more ETH!\");\n    //     // require(PriceConverter.getConversionRate(msg.value) >= MINIMUM_USD, \"You need to spend more ETH!\");\n    //     addressToAmountFunded[msg.sender] += msg.value;\n    //     funders.push(msg.sender);\n    // }\n    \n    // function getVersion() public view returns (uint256){\n    //     // ETH/USD price feed address of Sepolia Network.\n    //     AggregatorV3Interface priceFeed = AggregatorV3Interface(0x694AA1769357215DE4FAC081bf1f309aDC325306);\n    //     return priceFeed.version();\n    // }\n    \n    // modifier onlyOwner {\n    //     // require(msg.sender == owner);\n    //     if (msg.sender != i_owner) revert NotOwner();\n    //     _;\n    // }\n    \n    // function withdraw() public onlyOwner {\n    //     for (uint256 funderIndex=0; funderIndex < funders.length; funderIndex++){\n    //         address funder = funders[funderIndex];\n    //         addressToAmountFunded[funder] = 0;\n    //     }\n    //     funders = new address[](0);\n        // // transfer\n        // payable(msg.sender).transfer(address(this).balance);\n        // // send\n        // bool sendSuccess = payable(msg.sender).send(address(this).balance);\n        // require(sendSuccess, \"Send failed\");\n        // call\n    //     (bool callSuccess, ) = payable(msg.sender).call{value: address(this).balance}(\"\");\n    //     require(callSuccess, \"Call failed\");\n    // }\n    // Explainer from: https://solidity-by-example.org/fallback/\n    // Ether is sent to contract\n    //      is msg.data empty?\n    //          /   \\ \n    //         yes  no\n    //         /     \\\n    //    receive()?  fallback() \n    //     /   \\ \n    //   yes   no\n    //  /        \\\n    //receive()  fallback()\n\n//     fallback() external payable {\n//         fund();\n//     }\n\n//     receive() external payable {\n//         fund();\n//     }\n\n// }\n// */\n\n// Concepts we didn't cover yet (will cover in later sections)\n// 1. Enum\n// 2. Events\n// 3. Try / Catch\n// 4. Function Selector\n// 5. abi.encode / decode\n// 6. Hash with keccak256\n// 7. Yul / Assembly\n\n// */\n\n\n/*\n// 10:21:05 --> Mocking & helper-hardhat-config\n\nWe want to make changes to our contract\nwhen we want to deploy our script in localhost, we want to make use of a mock\nand when we want to change chains i.e avalance, sepolia, BNB, ethereum, polygon in chainlink-datafeed\nand we need keep in mind that different chians have different pricefeeds but still the similar functionality, because if we check\nthe address for ETH/USD for ethereum mainnet, is different from the address for ETH/USD for sepolia and others\n\nso we want to modularise/primariatized this address `AggregatorV3Interface priceFeed = AggregatorV3Interface(0x694AA1769357215DE4FAC081bf1f309aDC325306);`\nso that in different chains, we dont have to change any of our code\n\nwe would make few changes or refactor to our codes in this fundme.sol file\n\n1. We refactor our constructor function to hold our priceFeed address\n2. we created a variable with type AggregatorV3Interface\n3. we want to use our pricefeed variable in our price converter file\n4. in the fund() we added a second parameter `priceFeed`\n5. we remove getVersion() since we dont need it for now\n\n\npragma solidity ^0.8.8;\n\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\nimport \"./PriceConverter.sol\";\n\nerror NotOwner();\n\ncontract FundMe {\n    using PriceConverter for uint256;\n\n    mapping(address => uint256) public addressToAmountFunded;\n    address[] public funders;\n\n    // Could we make this constant?  /* hint: no! We should make it immutable! */\n    // address public /* immutable */ i_owner;\n    // uint256 public constant MINIMUM_USD = 50 * 10 ** 18;\n\n    // AggregatorV3Interface public priceFeed;\n    \n    // we want our constructor to have a parameter for our pricefeed\n    // so when we deploy our contract if keeps the price feed on anychain we are on i.e sepolia, avalanche, BNB\n    // constructor(address priceFeedAddress) {\n    //     i_owner = msg.sender;\n    //     priceFeed = AggregatorV3Interface(priceFeedAddress);\n    // }\n\n    // function fund() public payable {\n    //     require(msg.value.getConversionRate(priceFeed) >= MINIMUM_USD, \"You need to spend more ETH!\");\n    //     addressToAmountFunded[msg.sender] += msg.value;\n    //     funders.push(msg.sender);\n    // }\n    \n    // modifier onlyOwner {\n    //     if (msg.sender != i_owner) revert NotOwner();\n    //     _;\n    // }\n    \n    // function withdraw() public onlyOwner {\n    //     for (uint256 funderIndex=0; funderIndex < funders.length; funderIndex++){\n    //         address funder = funders[funderIndex];\n    //         addressToAmountFunded[funder] = 0;\n    //     }\n    //     funders = new address[](0);\n    \n    //     (bool callSuccess, ) = payable(msg.sender).call{value: address(this).balance}(\"\");\n    //     require(callSuccess, \"Call failed\");\n    // }\n\n    // fallback() external payable {\n    //     fund();\n    // }\n\n    // receive() external payable {\n    //     fund();\n    // }\n\n// }\n\n// */\n\n\n/*\n// 11:00:09 --> Solidity Style Guide \n\n// Here we want to clean up our FundMe contract to look more professional. \n// What we want to look out specifically is the \"Order of Layout\" which are below\n// 1. Pragma statements\n// 2. import statements\n// 3. Interfaces \n// 4. Libraries \n// 5. Contracts\n\n// And inside each contract, library or interface, use the following order:\n// 1. Type declearations\n// 2. State variables\n// 3. Events \n// 4. Modifiers \n// 5. Functions\n\n// 1st step -> We have done the pragma statements and import statements before which is good\n// Now it is becoming a best practice to add the name of your contract, some underscore and the name of your error like this below:\n//  `error VendingMachine__Unauthorized();`, which makes it a lot easier the contract that is making the error\n\n// 2nd step -> after that, since we dont have Interfaces, Libraries here but we have Contract.\n// So the next thing we would do now for how contract is to use NatSpec Format\n// NatSpec format stands for Ethereum Natural Language Specification Format, which is a way of documenting our code which is inspired by oxygen \n// So for example if we want to use NatSpec, we start will 3 backslash /// or /***/\n// and we explain that the FundMe contract does \n\n\n// 3rd step ->  we want to follow the order of our contract i.e type decleration, state variables, events, modifiers, functions\n\n// pragma solidity ^0.8.8;\n\n// import \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\n// import \"./PriceConverter.sol\";\n\n// // error NotOwner();\n// // We apply the best practice for errors that is linked directly to the contracts below:\n// // Error Codes\n// error FundMe__NotOwner();\n\n// // ---> the @dev is for note for developers\n// /**\n//  * @title A contract for crowd funding\n//  * @author Patrick Collins\n//  * @notice This contract is to demo a simple funding contract\n//  * @dev This implements price feeds as our library \n//  */\n\n// contract FundMe {\n//     // from 3rd step, we dont have type declearation except for PriceConverter as uint256\n//     // Type Declarations\n//     using PriceConverter for uint256;\n\n//     // State variables, we are going to change the names of some of our state variables\n//     // So for the `naming styles` we will change the naming later i.e to lowercase or uppercase e.t.c\n//     mapping(address => uint256) public addressToAmountFunded;\n//     address[] public funders;\n\n    \n//     address public immutable i_owner;\n//     uint256 public constant MINIMUM_USD = 50 * 10 ** 18;\n\n//     AggregatorV3Interface public priceFeed;\n\n//     // from 3rd step, We dont have events, but we have modifiers\n//     // Modifiers\n//     modifier onlyOwner {\n//         // if (msg.sender != i_owner) revert NotOwner();\n//         // Error Codes below\n//         if (msg.sender != i_owner) revert FundMe__NotOwner(); // Now we know that if we run into this error we will know that the error is coming from the FundMe contract and not AggregatorV3Interface or price converter of some other contract\n//         _;\n//     }\n\n//     // from 3rd step, we want to group our function in this order below:\n//     //// constructor\n//     //// receive\n//     //// fallback\n//     //// public\n//     //// internal \n//     //// private\n//     //// view / pure\n    \n//     constructor(address priceFeedAddress) {\n//         i_owner = msg.sender;\n//         priceFeed = AggregatorV3Interface(priceFeedAddress);\n//     }\n\n//     receive() external payable {\n//         fund();\n//     }\n\n//     fallback() external payable {\n//         fund();\n//     }\n\n//     // ---> Here we added the NatSpec for fund function\n//     // also in NatSpec we can add @params, @returns\n//     /**\n//      * @notice This function funds this contract\n//      * @dev This implements price feeds as our library \n//      */\n\n//     function fund() public payable {\n//         require(msg.value.getConversionRate(priceFeed) >= MINIMUM_USD, \"You need to spend more ETH!\");\n//         addressToAmountFunded[msg.sender] += msg.value;\n//         funders.push(msg.sender);\n//     }\n    \n//     function withdraw() public onlyOwner {\n//         for (uint256 funderIndex=0; funderIndex < funders.length; funderIndex++){\n//             address funder = funders[funderIndex];\n//             addressToAmountFunded[funder] = 0;\n//         }\n//         funders = new address[](0);\n    \n//         (bool callSuccess, ) = payable(msg.sender).call{value: address(this).balance}(\"\");\n//         require(callSuccess, \"Call failed\");\n//     }\n\n// }\n\n// */\n\n\n// 11:00:09 --> Solidity Style Guide, without comments\n\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.8;\n\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\nimport \"./PriceConverter.sol\";\n\nerror FundMe__NotOwner();\n\n/**\n * @title A contract for crowd funding\n * @author Patrick Collins\n * @notice This contract is to demo a simple funding contract\n * @dev This implements price feeds as our library \n */\n\ncontract FundMe {\n    using PriceConverter for uint256;\n\n    mapping(address => uint256) public addressToAmountFunded;\n    address[] public funders;\n\n    \n    address public immutable i_owner;\n    uint256 public constant MINIMUM_USD = 50 * 10 ** 18;\n\n    AggregatorV3Interface public priceFeed;\n\n    modifier onlyOwner {\n        if (msg.sender != i_owner) revert FundMe__NotOwner(); \n        _;\n    }\n\n    \n    constructor(address priceFeedAddress) {\n        i_owner = msg.sender;\n        priceFeed = AggregatorV3Interface(priceFeedAddress);\n    }\n\n    receive() external payable {\n        fund();\n    }\n\n    fallback() external payable {\n        fund();\n    }\n\n    /**\n     * @notice This function funds this contract\n     * @dev This implements price feeds as our library \n     */\n\n    function fund() public payable {\n        require(msg.value.getConversionRate(priceFeed) >= MINIMUM_USD, \"You need to spend more ETH!\");\n        addressToAmountFunded[msg.sender] += msg.value;\n        funders.push(msg.sender);\n    }\n    \n    function withdraw() public onlyOwner {\n        for (uint256 funderIndex=0; funderIndex < funders.length; funderIndex++){\n            address funder = funders[funderIndex];\n            addressToAmountFunded[funder] = 0;\n        }\n        funders = new address[](0);\n    \n        (bool callSuccess, ) = payable(msg.sender).call{value: address(this).balance}(\"\");\n        require(callSuccess, \"Call failed\");\n    }\n\n}\n\n\n\n\n"
    },
    "@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface AggregatorV3Interface {\n  function decimals() external view returns (uint8);\n\n  function description() external view returns (string memory);\n\n  function version() external view returns (uint256);\n\n  // getRoundData and latestRoundData should both raise \"No data present\"\n  // if they do not have data to report, instead of returning unset values\n  // which could be misinterpreted as actual reported values.\n  function getRoundData(uint80 _roundId)\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n  function latestRoundData()\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n}\n"
    },
    "contracts/PriceConverter.sol": {
      "content": "/*\npragma solidity ^0.8.8;\n\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\n\n// Why is this a library and not abstract?\n// Why not an interface?\nlibrary PriceConverter {\n    // We could make this public, but then we'd have to deploy it\n    function getPrice() internal view returns (uint256) {\n        // Sepolia ETH / USD Address\n        // https://docs.chain.link/data-feeds/price-feeds/addresses#Sepolia%20Testnet\n        AggregatorV3Interface priceFeed = AggregatorV3Interface(\n            0x694AA1769357215DE4FAC081bf1f309aDC325306\n        );\n        (, int256 answer, , , ) = priceFeed.latestRoundData();\n        // ETH/USD rate in 18 digit\n        return uint256(answer * 10000000000);\n        // or (Both will do the same thing)\n        // return uint256(answer * 1e10); // 1* 10 ** 10 == 10000000000\n    }\n\n    // 1000000000\n    function getConversionRate(uint256 ethAmount)\n        internal\n        view\n        returns (uint256)\n    {\n        uint256 ethPrice = getPrice();\n        uint256 ethAmountInUsd = (ethPrice * ethAmount) / 1000000000000000000;\n        // or (Both will do the same thing)\n        // uint256 ethAmountInUsd = (ethPrice * ethAmount) / 1e18; // 1 * 10 ** 18 == 1000000000000000000\n        // the actual ETH/USD conversion rate, after adjusting the extra 0s.\n        return ethAmountInUsd;\n    }\n}\n*/\n\n// 10:27:00 --> Mocking & helper-hardhat-config\n// we dont need to hardcode this again `AggregatorV3Interface priceFeed = AggregatorV3Interface(0x694AA1769357215DE4FAC081bf1f309aDC325306);`\n// since we have a variable called priceFeed that keeps it\n// we refactor our getConversionRate() to add a second parameter called `AggregatorV3Interface priceFeed`\n\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.8;\n\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\n\nlibrary PriceConverter {\n    \n    function getPrice(AggregatorV3Interface priceFeed) internal view returns (uint256) {\n        (, int256 answer, , , ) = priceFeed.latestRoundData();\n        return uint256(answer * 10000000000);\n    }\n\n    function getConversionRate(uint256 ethAmount, AggregatorV3Interface priceFeed)\n        internal\n        view\n        returns (uint256)\n    {\n        uint256 ethPrice = getPrice(priceFeed);\n        uint256 ethAmountInUsd = (ethPrice * ethAmount) / 1000000000000000000;\n        return ethAmountInUsd;\n    }\n}\n\n\n\n\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}